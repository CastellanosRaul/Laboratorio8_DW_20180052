---
title: "Missing data and Feature Engineering"
output: rmarkdown::github_document
---

## Laboratorio 8, Raul Castellanos 20180052

#Parte 1

```{r, cache=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(readr)
library(tidyr)
library(stringr)
library(modeest)
library(DataExplorer)
library(DT)
library(gdata)
timd <- read_csv("titanic_MD.csv")
ti <- read_csv("titanic.csv")
```

### Inciso 1: Reporte detallado de missing data para todas las columnas

```{r}
summary(timd)
```

#### Columnas con missing data
* Sex
* Age
* SibSp 
* Parch
* Fare 
* Embarked

### Inciso 2: Para cada columna especificar que tipo de modelo se utilizará y qué valores se le darán a todos los missing values

* Para la columna de Sex: filling values ya que en la columna de name están las abreviaviones como: Mr, Mrs, Miss, Master, Sir, Mme, Dr, Major, Countess

* Para la columna de Age: Prediccion con Regresión lineal con la relación de las columnas Age y Survived

* Para la columna de SibSp: llenar los valores NA por imputación de la media 

* Para la columna de Parch: llenar los valores NA por imputación de la moda

* Para la columna de Fare: llenar los valores NA por imputación de la media 

* Para la colimna de Embarked: filling values top to down

### Inciso 3: Reporte de qué filas están completas 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd$Sex2 <- ifelse(timd$Sex == "female", 0,
                     ifelse(timd$Sex == "male", 1, NA))
paste0("Hay ", nrow(na.omit(timd)), " filas completas")
```


### Inciso 4: Utilizar los siguientes métodos para cada columna que contiene missing values:
#### * Pairwise deletion
#### * Imputación general (media, moda y mediana)
#### * Imputación sectorizada
#### * Modelo de regresión lineal simple
#### * Eliminación de outliers: Standard deviation approach
#### * Eliminación de outliers: Percentile approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2 <- read_csv("titanic_MD.csv")
```

#### Funciones Generales

* Imputación, Media, Mediana y Moda

```{r, cache=TRUE, message=FALSE, warning=FALSE}
Imputacion_MMM <- function(df, columna){
  if(columna == 6){
    df$media <- NA
    df$mediana <- NA
    df$moda <- NA
    df$media <- ifelse(is.na(df$Age), round(mean(df$Age, na.rm = TRUE),0), df$Age)
    df$mediana <- ifelse(is.na(df$Age), round(median(df$Age, na.rm = TRUE),0), df$Age)
    df$moda <- ifelse(is.na(df$Age), round(mfv1(df$Age, na_rm = TRUE),0), df$Age)
    MMM <- cbind.data.frame(df$media, df$mediana, df$moda)
  }
  else if(columna == 7){
    df$media <- NA
    df$mediana <- NA
    df$moda <- NA
    df$media <- ifelse(is.na(df$SibSp), round(mean(df$SibSp, na.rm = TRUE),0), df$SibSp)
    df$mediana <- ifelse(is.na(df$SibSp), round(median(df$SibSp, na.rm = TRUE),0), df$SibSp)
    df$moda <- ifelse(is.na(df$SibSp), round(mfv1(df$SibSp, na_rm = TRUE),0), df$SibSp)
    MMM <- cbind.data.frame(df$media, df$mediana, df$moda)
  }
  else if(columna == 8){
    df$media <- NA
    df$mediana <- NA
    df$moda <- NA
    df$media <- ifelse(is.na(df$Parch), round(mean(df$Parch, na.rm = TRUE),0), df$Parch)
    df$mediana <- ifelse(is.na(df$Parch), round(median(df$Parch, na.rm = TRUE),0), df$Parch)
    df$moda <- ifelse(is.na(df$Parch), round(mfv1(df$Parch, na_rm = TRUE),0), df$Parch)
    MMM <- cbind.data.frame(df$media, df$mediana, df$moda)
  }
  else if(columna == 10){
    df$media <- NA
    df$mediana <- NA
    df$moda <- NA
    df$media <- ifelse(is.na(df$Fare), round(mean(df$Fare, na.rm = TRUE),0), df$Fare)
    df$mediana <- ifelse(is.na(df$Fare), round(median(df$Fare, na.rm = TRUE),0), df$Fare)
    df$moda <- ifelse(is.na(df$Fare), round(mfv1(df$Fare, na_rm = TRUE),0), df$Fare)
    MMM <- cbind.data.frame(df$media, df$mediana, df$moda)
  }
  return(as.data.frame(MMM))
}
```

* Imputacion sectorizada

```{r, cache=TRUE, message=FALSE, warning=FALSE}
Imputacion_Sectorizada <- function(df, columna){
  if(columna == 6){
    df$IS <- NA
    g <- df %>% filter(!is.na(df$Age)) %>% group_by(Age) %>% summarise(freq = n(), .groups = 'drop') %>% arrange(desc(freq))
    a <- as.numeric(g[1,1])
    df$IS <- ifelse(is.na(df$Age), a, df$Age)
    ISM <- df$IS
  }
  else if(columna == 7){
    df$IS <- NA
    g <- df %>% filter(!is.na(df$SibSp)) %>% group_by(SibSp) %>% summarise(freq = n(), .groups = 'drop') %>% arrange(desc(freq))
    a <- as.numeric(g[1,1])
    df$IS <- ifelse(is.na(df$SibSp), a, df$SibSp)
    ISM <- df$IS
  }
  else if(columna == 8){
    df$IS <- NA
    g <- df %>% filter(!is.na(df$Parch)) %>% group_by(Parch) %>% summarise(freq = n(), .groups = 'drop') %>% arrange(desc(freq))
    a <- as.numeric(g[1,1])
    df$IS <- ifelse(is.na(df$Parch), a, df$Parch)
    ISM <- df$IS
  }
  else if(columna == 10){
    df$IS <- NA
    g <- df %>% filter(!is.na(df$Fare)) %>% group_by(Fare) %>% summarise(freq = n(), .groups = 'drop') %>% arrange(desc(freq))
    a <- as.numeric(g[1,1])
    df$IS <- ifelse(is.na(df$Fare), a, df$Fare)
    ISM <- df$IS
  }
  return(as.data.frame(ISM))
}
```

* Regresion Lineal 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
RegresionLineal <- function(df, columna, columna2){
  if(columna == 6 & columna2 == 2){
    df$RLineal <- NA
    a <- lm(Age ~ Survived, df)
    df$RLineal <- ifelse(is.na(df$Age), round((a$coefficients[1] + a$coefficients[2]*df$Survived),0), df$Age)
    RL <- df$RLineal
  }
  else if(columna == 6 & columna2 == 3){
    df$RLineal <- NA
    a <- lm(Age ~ Pclass, df)
    df$RLineal <- ifelse(is.na(df$Age), round((a$coefficients[1] + a$coefficients[2]*df$Pclass),0), df$Age)
    RL <- df$RLineal
  }
  else if(columna == 7 & columna2 == 2){
    df$RLineal <- NA
    a <- lm(SibSp ~ Survived, df)
    df$RLineal <- ifelse(is.na(df$SibSp), round((a$coefficients[1] + a$coefficients[2]*df$Survived),0), df$SibSp)
    RL <- df$RLineal
  }
  else if(columna == 7 & columna2 == 3){
    df$RLineal <- NA
    a <- lm(SibSp ~ Pclass, df)
    df$RLineal <- ifelse(is.na(df$SibSp), round((a$coefficients[1] + a$coefficients[2]*df$Pclass),0), df$SibSp)
    RL <- df$RLineal
  }
  else if(columna == 8 & columna2 == 2){
    df$RLineal <- NA
    a <- lm(Parch ~ Survived, df)
    df$RLineal <- ifelse(is.na(df$Parch), round((a$coefficients[1] + a$coefficients[2]*df$Survived),0), df$Parch)
    RL <- df$RLineal
  }
  else if(columna == 8 & columna2 == 3){
    df$RLineal <- NA
    a <- lm(Parch ~ Pclass, df)
    df$RLineal <- ifelse(is.na(df$Parch), round((a$coefficients[1] + a$coefficients[2]*df$Pclass),0), df$Parch)
    RL <- df$RLineal
  }
  else if(columna == 10 & columna2 == 2){
    df$RLineal <- NA
    a <- lm(Fare ~ Survived, df)
    df$RLineal <- ifelse(is.na(df$Fare), round((a$coefficients[1] + a$coefficients[2]*df$Survived),0), df$Fare)
    RL <- df$RLineal
  }
  else if(columna == 10 & columna2 == 3){
    df$RLineal <- NA
    a <- lm(Age ~ Fare, df)
    df$RLineal <- ifelse(is.na(df$Fare), round((a$coefficients[1] + a$coefficients[2]*df$Pclass),0), df$Fare)
    RL <- df$RLineal
  }
  return(as.data.frame(RL))
}
```

* Standard Deviation Approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
StandardDev_Approach <- function(df, columna){
  if(columna == 6){
    x <- 3
    Lower <- mean(df$Age, na.rm = TRUE) - (sd(df$Age, na.rm = TRUE)*x)
    Upper <- mean(df$Age, na.rm = TRUE) + (sd(df$Age, na.rm = TRUE)*x)
    Sd <- df[(!is.na(df$Age)) & (df$Age >= Lower) & (df$Age <= Upper),]
    SDA <- Sd$Age
  }
  else if(columna == 7){
    x <- 3
    Lower <- mean(df$SibSp, na.rm = TRUE) - (sd(df$SibSp, na.rm = TRUE)*x)
    Upper <- mean(df$SibSp, na.rm = TRUE) + (sd(df$SibSp, na.rm = TRUE)*x)
    Sd <- df[(!is.na(df$SibSp)) & (df$SibSp >= Lower) & (df$SibSp <= Upper),]
    SDA <- Sd$SibSp
  }
  else if(columna == 8){
    x <- 3
    Lower <- mean(df$Parch, na.rm = TRUE) - (sd(df$Parch, na.rm = TRUE)*x)
    Upper <- mean(df$Parch, na.rm = TRUE) + (sd(df$Parch, na.rm = TRUE)*x)
    Sd <- df[(!is.na(df$Parch)) & (df$Parch >= Lower) & (df$Parch <= Upper),]
    SDA <- Sd$Parch
  }
  else if(columna == 10){
    x <- 3
    Lower <- mean(df$Fare, na.rm = TRUE) - (sd(df$Fare, na.rm = TRUE)*x)
    Upper <- mean(df$Fare, na.rm = TRUE) + (sd(df$Fare, na.rm = TRUE)*x)
    Sd <- df[(!is.na(df$Fare)) & (df$Fare >= Lower) & (df$Fare <= Upper),]
    SDA <- Sd$Fare
  }
  return(as.data.frame(SDA))
}
```

* Percentile Approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
Percentile_Approach <- function(df, columna){
  if(columna == 6){
    Lower <- quantile(df$Age, na.rm = TRUE, probs = 0.1)
    Upper <- quantile(df$Age, na.rm = TRUE, probs = 0.9)
    Pa <- df[(!is.na(df$Age)) & (df$Age >= Lower) & (df$Age <= Upper),]
    PA <- Pa$Age
  }
  else if(columna == 7){
    Lower <- quantile(df$SibSp, na.rm = TRUE, probs = 0.1)
    Upper <- quantile(df$SibSp, na.rm = TRUE, probs = 0.9)
    Pa <- df[(!is.na(df$SibSp)) & (df$SibSp >= Lower) & (df$SibSp <= Upper),]
    PA <- Pa$SibSp
  }
  else if(columna == 8){
    Lower <- quantile(df$Parch, na.rm = TRUE, probs = 0.1)
    Upper <- quantile(df$Parch, na.rm = TRUE, probs = 0.9)
    Pa <- df[(!is.na(df$Parch)) & (df$Parch >= Lower) & (df$Parch <= Upper),]
    PA <- Pa$Parch
  }
  else if(columna == 10){
    Lower <- quantile(df$Fare, na.rm = TRUE, probs = 0.1)
    Upper <- quantile(df$Fare, na.rm = TRUE, probs = 0.9)
    Pa <- df[(!is.na(df$Fare)) & (df$Fare >= Lower) & (df$Fare <= Upper),]
    PA <- Pa$Fare
  }
  return(as.data.frame(PA))
}
```


#### Columna: Sex

* Los siguientes métodos no aplican para esta columna ya que esta columna tiene valores categóricos:
  + Pairwise deletion
  + Imutación por media y mediana
  + Regresión Lineal
  + Eliminación de outliers: Standard deviation approach
  + Eliminación de outliers: Percentile approach

* Imputación por moda
```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2$Sex2 <- ifelse(timd2$Sex == "female", 0,
                     ifelse(timd2$Sex == "male", 1, NA))
timd2$Sex <- ifelse(is.na(timd2$Sex2), mfv1(timd2$Sex2, na_rm = TRUE), timd2$Sex2)
datatable(timd2[1:10, 5])

# Cero = female y Uno = male
```

* Filling Values con informacion adicional (columna Name)

```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2$Sex <- ifelse(str_detect(timd2$Name, "Mrs|Miss|Mme|Mlle|Countess"), "female", "male")
Sex <- as.data.frame(timd2$Sex)
datatable(Sex)
```


#### Columna: Age

* Deletion Pairwise

```{r, cache=TRUE, message=FALSE, warning=FALSE}
cor(timd2$Age, timd2$Survived, use = "pairwise.complete.obs")
```

* Imputación Media, Mediana y Moda

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_MMM(timd2, 6))
```

* Imputación sectorizada 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_Sectorizada(timd2, 6))
```


* Regresion Lineal

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(RegresionLineal(timd2, 6, 3))
```

* Eliminación de outliers: Standard deviation approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(StandardDev_Approach(timd2, 6))
```

* Eliminación de outliers: Percentile approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Percentile_Approach(timd2, 6))
```

#### Columna: SibSp

* Deletion Pairwise

```{r, cache=TRUE, message=FALSE, warning=FALSE}
cor(timd2$SibSp, timd2$Pclass, use = "pairwise.complete.obs")
```

* Imputación Media, Mediana y Moda

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_MMM(timd2, 7))
```

* Imputación sectorizada 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_Sectorizada(timd2, 7))
```


* Regresion Lineal

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(RegresionLineal(timd2, 7, 3))
```

* Eliminación de outliers: Standard deviation approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(StandardDev_Approach(timd2, 7))
```

* Eliminación de outliers: Percentile approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Percentile_Approach(timd2, 7))
```

#### Columna: Parch

* Deletion Pairwise

```{r, cache=TRUE, message=FALSE, warning=FALSE}
cor(timd2$Parch, timd2$Pclass, use = "pairwise.complete.obs")
```

* Imputación Media, Mediana y Moda

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_MMM(timd2, 8))
```

* Imputación sectorizada 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_Sectorizada(timd2, 8))
```


* Regresion Lineal

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(RegresionLineal(timd2, 8, 3))
```

* Eliminación de outliers: Standard deviation approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(StandardDev_Approach(timd2, 8))
```

* Eliminación de outliers: Percentile approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Percentile_Approach(timd2, 8))
```

#### Columna: Fare

* Deletion Pairwise

```{r, cache=TRUE, message=FALSE, warning=FALSE}
cor(timd2$Fare, timd2$Pclass, use = "pairwise.complete.obs")
```

* Imputación Media, Mediana y Moda

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_MMM(timd2, 10))
```

* Imputación sectorizada 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Imputacion_Sectorizada(timd2, 10))
```


* Regresion Lineal

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(RegresionLineal(timd2, 10, 3))
```

* Eliminación de outliers: Standard deviation approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(StandardDev_Approach(timd2, 10))
```

* Eliminación de outliers: Percentile approach

```{r, cache=TRUE, message=FALSE, warning=FALSE}
datatable(Percentile_Approach(timd2, 10))
```

#### Columna: Embarked

* Los siguientes métodos no aplican para esta columna ya que esta columna tiene valores categóricos:
  + Pairwise deletion
  + Imutación por media y mediana
  + Regresión Lineal
  + Eliminación de outliers: Standard deviation approach
  + Eliminación de outliers: Percentile approach

* Imputación por moda
```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2$Embarked2 <- ifelse(timd2$Embarked == "C", 1,
                          ifelse(timd2$Embarked == "Q", 2,
                                 ifelse(timd2$Embarked == "S", 3,NA)))
timd2$Embarked <- ifelse(is.na(timd2$Embarked), mfv1(timd2$Embarked2, na_rm = TRUE), timd2$Embarked)
datatable(timd2[1:10, 12])
```


* Filling Values Top to Down

```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2 <- timd2 %>% fill(Embarked)
datatable(timd2[1:10, 12])
```

### Inciso 5: Al comparar los métodos del inciso 4 contra “titanic.csv”, ¿Qué método (para cada columna) se acerca más a la realidad y por qué?

#### Sex

```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2$Sex2 <- ifelse(timd2$Sex == "female", 0,
                     ifelse(timd2$Sex == "male", 1, NA))
timd2$Sex3 <- ifelse(is.na(timd2$Sex2), mfv1(timd2$Sex2, na_rm = TRUE), timd2$Sex2)
Sexo_Moda <- timd2 %>% select(Sex3)
Sexo_Moda$Sex3 <- ifelse(Sexo_Moda$Sex3 == 0, "female", "male")

timd2$Sex <- ifelse(str_detect(timd2$Name, "Mrs|Miss|Mme|Mlle|Countess"), "female", "male")
Sexo_FillValues <- timd2 %>% select(Sex)

Sex <- ti %>% select(Sex)

Sexo <- cbindX(Sex, Sexo_Moda, Sexo_FillValues)

colnames(Sexo) <- c("Original", "Imp_Moda", "Fill_Values")

datatable(Sexo)
```

Podemos observar que los dos metodos devolvieron un resultado igual al de la data original, el que más se acerca a la realidad sería el de Filling Values, ya que con la información del nombre se puede obtener un resultado muy cercano a la realidad.

#### Age

```{r, cache=TRUE, message=FALSE, warning=FALSE}
paste("La correlación entre la edad y sobrevivir es de: ", cor(timd2$Age, timd2$Survived, use = "pairwise.complete.obs"), sep = " ")

Age_MediaMedianaModa <- Imputacion_MMM(timd2, 6)
Age_ImpSectorizada <- Imputacion_Sectorizada(timd2, 6)
Age_Regresion <- RegresionLineal(timd2, 6, 3)
Age_StDevApproach <- StandardDev_Approach(timd2, 6)
Age_Percentile <- Percentile_Approach(timd2, 6)
Age_Original <- ti %>% select(Age)

Age <- cbindX(Age_Original, Age_MediaMedianaModa, Age_ImpSectorizada, Age_Regresion, 
              Age_StDevApproach, Age_Percentile)
colnames(Age) <- c("Original", "Media", "Mediana", "Moda", "Imp_SecModa", "R_Lineal", "Sd_App", "Perc_App")
datatable(Age)
```

Como podemos observar en la tabla (fila 4) el método que más se le acerca es el método de regresión lineal, correlación x,y Age,Survived, ya que es el que se le acerca más a la edad original.

#### SibSp

```{r, cache=TRUE, message=FALSE, warning=FALSE}
paste("La correlación entre el número de hermanos o esposas en el barco y la clase del pasajero es de: ", cor(timd2$SibSp, timd2$Pclass, use = "pairwise.complete.obs"), sep = " ")

SibSp_MediaMedianaModa <- Imputacion_MMM(timd2, 7)
SibSp_ImpSectorizada <- Imputacion_Sectorizada(timd2, 7)
SibSp_Regresion <- RegresionLineal(timd2, 7, 3)
SibSp_StDevApproach <- StandardDev_Approach(timd2, 7)
SibSp_Percentile <- Percentile_Approach(timd2, 7)
SibSp_Original <- ti %>% select(SibSp)

SibSp <- cbindX(SibSp_Original, SibSp_MediaMedianaModa, SibSp_ImpSectorizada, SibSp_Regresion, 
              SibSp_StDevApproach, SibSp_Percentile)
colnames(SibSp) <- c("Original", "Media", "Mediana", "Moda", "Imp_SecModa", "R_Lineal", "Sd_App", "Perc_App")
datatable(SibSp)
```

El modelo que más se le acercaría a esta columna es el de imputación por moda, ya que los valores que podría tomar esta columna podrían ser muy parecidos y repetitivos.

#### Parch

```{r, cache=TRUE, message=FALSE, warning=FALSE}
paste("La correlación entre tener padres o hijos en el barco y la clase del pasajero es de: ", cor(timd2$Parch, timd2$Pclass, use = "pairwise.complete.obs"), sep = " ")

Parch_MediaMedianaModa <- Imputacion_MMM(timd2, 8)
Parch_ImpSectorizada <- Imputacion_Sectorizada(timd2, 8)
Parch_Regresion <- RegresionLineal(timd2, 8, 3)
Parch_StDevApproach <- StandardDev_Approach(timd2, 8)
Parch_Percentile <- Percentile_Approach(timd2, 8)
  Parch_Original <- ti %>% select(Parch)

Parch <- cbindX(Parch_Original, Parch_MediaMedianaModa, Parch_ImpSectorizada, Parch_Regresion, 
              Parch_StDevApproach, Parch_Percentile)
colnames(Parch) <- c("Original", "Media", "Mediana", "Moda", "Imp_SecModa", "R_Lineal", "Sd_App", "Perc_App")
datatable(Parch)
```

El método que más se acerca a la realidad para esta columna es el método de regresión lineal, ya que en la fila 4 y fila 9 la regresión pudo calcular el valor que tomaría por medio de la correlación entre Parch y Pclass, ya que tienen una correlación cercana a uno y los datos calculados se ajustan más a la edad real según la variable de clase de pasajero.

#### Fare

```{r, cache=TRUE, message=FALSE, warning=FALSE}
paste("La correlación entre la tarifa de pago y la clase del pasajero es de: ", cor(timd2$Fare, timd2$Pclass, use = "pairwise.complete.obs"), sep = " ")

Fare_MediaMedianaModa <- Imputacion_MMM(timd2, 10)
Fare_ImpSectorizada <- Imputacion_Sectorizada(timd2, 10)
Fare_Regresion <- RegresionLineal(timd2, 10, 3)
Fare_StDevApproach <- StandardDev_Approach(timd2, 10)
Fare_Percentile <- Percentile_Approach(timd2, 10)
Fare_Original <- ti %>% select(Fare)

Fare <- cbindX(Fare_Original, Fare_MediaMedianaModa, Fare_ImpSectorizada, Fare_Regresion, 
              Fare_StDevApproach, Fare_Percentile)
colnames(Fare) <- c("Original", "Media", "Mediana", "Moda", "Imp_SecModa", "R_Lineal", "Sd_App", "Perc_App")
datatable(Fare)
```

Para esta columna, sería mejor utilizar el Standard Deviation Approach, ya que se puede observar que hay distinras tarifas a los pasajeros, entonces sería mejor omitir los NA con este método y escoger la data en algún rango debido a que asignar alguna tarifa con los otros métodos no sería tan bueno ya que sesgar los datos y tener mala información sobre las tarifas.

#### Embarked

```{r, cache=TRUE, message=FALSE, warning=FALSE}
timd2$Embarked2 <- ifelse(timd2$Embarked == "C", 1,
                          ifelse(timd2$Embarked == "Q", 2,
                                 ifelse(timd2$Embarked == "S", 3, NA)))
timd2$Embarked3 <- ifelse(is.na(timd2$Embarked2), mfv1(timd2$Embarked2, na_rm = TRUE), timd2$Embarked2)

timd2$Embarked4 <- ifelse(timd2$Embarked3 == 1, "C",
                                  ifelse(timd2$Embarked3 == 2, "Q", "S"))

Embarked_Moda <- timd2 %>% select(Embarked4)

Embarked_Fill <- timd2 %>% fill(Embarked)
Embarked_Fill$Embarked <- ifelse(Embarked_Fill$Embarked == "3", "S", Embarked_Fill$Embarked)
Embarked_Fill <- Embarked_Fill %>% select(Embarked)

Embarked_Original <- ti %>% select(Embarked)

Embarked <- cbindX(Embarked_Original, Embarked_Moda, Embarked_Fill)
colnames(Embarked) <- c("Original", "Moda", "Fill_Values")

datatable(Embarked)
```
Para esta columna el método que más se le acercaría a la realidad sería el de imputación por moda, ya que al tener sólo 3 categorías, elegir el más repetitivo para rellenar un NA es mejor que llenar los datos top to down porque la información estadística podría ser mejor.

### Inciso 6: Conclusiones

El método de filling values with information available (utilizado en la columna de Sex) es un buen método para poder rellenar los missing values según la información que creamos necesaria utilizar para rellenar estos. 

El método de imputación de media, mediana, moda y moda sectorizada, podría ser una buena opción para rellenar los missing values en las columnas que tengan valores cercanos o en secuencia ya que al ser imputaciones estadísticas estas podrían sesgar los datos, por ejemplo en las columnas de: Sex, Embarked, SibSp toman valores muy cercanos y sería más conveniente llenar los NA con estos métodos en el caso de no tener información adicional.

El modelo de regresión lineal, puede ser bastante conveniente de utilizar cuándo las variables a utilizar tienen una correlacion casi perfecta o cercana a uno, por ejemplo la columna de hijos y padres en el barco (Parch) tiene una correlación muy buena con la de clase, la cuál permite calcular una mejor aproximación de los valores.

Los modelos de eliminación de outliers por medio de Standar Deviation Approach o Percentile Approach, son útiles cuando la variable que contenga missing data tenga datos muy diferentes, que podrían ser aleatorios o asignados discriminadamente, por ejemplo con la columna de fare, a tener datos muy variados sería mejor remover los NA y trabajar con los datos que estos outliers los recomiendan según los rangos.

# Parte 2

### Inciso 1: Luego del pre-procesamiento de la data con Missing Values, normalice las columnas numéricas por los métodos: 

### a. Standarization
### b. MinMaxScaling
### c. MaxAbsScaler

```{r, cache=TRUE, message=FALSE, warning=FALSE}
ZValue <- function(df, columna){
 if(columna == 6){
   Z <- df %>% mutate(Z_Age = (Age - mean(Age, na.rm = TRUE))/sd(Age, na.rm = TRUE))
   Z <- Z %>% select(Z_Age)
   return(as.data.frame(Z))
 }
 
 else if(columna == 10){
   Z <- df %>% mutate(Z_Fare = (Fare - mean(Fare, na.rm = TRUE))/sd(Fare, na.rm = TRUE))
   Z <- Z %>% select(Z_Fare)
   return(as.data.frame(Z))
 }
}

MinMax <- function(df, columna){
  if(columna == 6){
    MM <- df %>% mutate(MM_Age = (Age - min(Age, na.rm = TRUE))/(max(Age, na.rm = TRUE)-min(Age, na.rm = TRUE)))
    MM <- MM %>% select(MM_Age)
    return(as.data.frame(MM))
  }
  
  else if(columna == 10){
    MM <- df %>% mutate(MM_Fare = (Fare - min(Fare, na.rm = TRUE))/(max(Fare, na.rm = TRUE)-min(Fare, na.rm = TRUE)))
    MM <- MM %>% select(MM_Fare)
    return(as.data.frame(MM))
  }
}

MaxAbs <- function(df, columna){
  if(columna == 6){
    Max <- max(df$Age, na.rm = TRUE)
    Min <- min(df$Age, na.rm = TRUE)
    MA <- df %>% mutate(MA_Age = (Age - mean(c(Max,Min))) / (Max - mean(c(Max,Min))))
    MMA<- MA %>% select(MA_Age)
    return(as.data.frame(MMA))
  }
  
  if(columna == 10){
    Max <- max(df$Fare, na.rm = TRUE)
    Min <- min(df$Fare, na.rm = TRUE)
    MA <- df %>% mutate(MA_Fare = (Fare - mean(c(Max,Min))) / (Max - mean(c(Max,Min))))
    MMA<- MA %>% select(MA_Fare)
    return(as.data.frame(MMA))
  }
}
```

Sólo se podrán normalizar las columnas numéricas cuyos valores sean muy dispersos y que no sigan una buena distribución
Columnas que se le aplicarán los métodos: Age y Fare

#### Age 
```{r, cache=TRUE, message=FALSE, warning=FALSE}
Z_Age <- ZValue(timd2, 6)
MinMax_Age <- MinMax(timd2, 6)
MaxAbs_Age <- MaxAbs(timd2, 6)

Age_Normalized <- cbindX(Z_Age, MinMax_Age, MaxAbs_Age)
datatable(Age_Normalized)
```

#### Fare 
```{r, cache=TRUE, message=FALSE, warning=FALSE}
Z_Fare <- ZValue(timd2, 10)
MinMax_Fare <- MinMax(timd2, 10)
MaxAbs_Fare <- MaxAbs(timd2, 10)

Fare_Normalized <- cbindX(Z_Fare, MinMax_Fare, MaxAbs_Fare)
datatable(Fare_Normalized)
```


### Inciso 2: Compare los estadísticos que considere más importantes para su conclusión y compare contra la data completa de “titanic.csv” 

#### Comparación por histogramas para la columna de Age 

```{r, cache=TRUE, message=FALSE, warning=FALSE}
library(ggplot2)
ggplot(ti, aes(Age)) + 
  geom_histogram(color="black", fill = "blue") + 
  labs(title = "Histograma para la variable Age Original")

ggplot(Age_Normalized, aes(Z_Age)) + 
  geom_histogram(color="black", fill = "red") + 
  labs(title = "Histograma para la variable Age Original")

ggplot(Age_Normalized, aes(MM_Age)) + 
  geom_histogram(color="black", fill = "green") + 
  labs(title = "Histograma para la variable Age Original")

ggplot(Age_Normalized, aes(MA_Age)) + 
  geom_histogram(color="black", fill = "lightblue") + 
  labs(title = "Histograma para la variable Age Original")
```

```{r, cache=TRUE, message=FALSE, warning=FALSE}
ggplot(ti, aes(Fare)) + 
  geom_histogram(color="black", fill = "gold") + 
  labs(title = "Histograma para la variable Age Original")

ggplot(Fare_Normalized, aes(Z_Fare)) + 
  geom_histogram(color="black", fill = "darkblue") + 
  labs(title = "Histograma para la variable Age Original")

ggplot(Fare_Normalized, aes(MM_Fare)) + 
  geom_histogram(color="black", fill = "pink") + 
  labs(title = "Histograma para la variable Age Original")

ggplot(Fare_Normalized, aes(MA_Fare)) + 
  geom_histogram(color="black", fill = "lightblue") + 
  labs(title = "Histograma para la variable Age Original")
```

Como podemos observar en los histogramas los metodos de MinMaxScaling y MaxAbsScaling se acercan mucho al histograma original de la data, con esto podría concluir que utilizar uno los dos métodos sería lo mejor para poder normalizar la data con base a sus datos estadísticos de máximos y mínimos.
